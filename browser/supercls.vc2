*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="supercls.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: Class Library: Superclass Utilities     Author:  Ken Levy, Flash Creative Management, Inc. />
*
DEFINE CLASS editmethodshortcutmenu AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	*<DefinedPropArrayMethod>
		*m: activatemenu
		*m: addmenubar
		*m: addmenuseparator
		*m: clearmenu
		*m: deactivatemenu
		*m: newmenu
		*m: release		&& Releases a FormSet or Form from memory.
		*m: setmenu
		*m: showmenu
		*p: cmenu
		*p: conselection
		*p: ndefaultbar
		*p: ohost
		*a: amenu[1,0]
	*</DefinedPropArrayMethod>

	cmenu = 
	conselection = 
	Height = 22
	Name = "editmethodshortcutmenu"
	ndefaultbar = 1
	ohost = .NULL.
	Width = 24
	
	PROCEDURE activatemenu
		LPARAMETERS tcParentMenu
		LOCAL lnArrayColumns,llMultiArray,lnBar,lnSkipCount,lnCount,lnMRow,lnMCol
		LOCAL lnMenuCount,lcMenu,lcMenu2,lcMenuItem,luMenuSelection,llSetMark,lcClauses
		
		lnMRow=MAX(MROW(),0)
		lnMCol=MAX(MCOL(),0)
		IF TYPE("this.aMenu")#"C"
			RETURN .F.
		ENDIF
		lnMenuCount=ALEN(this.aMenu,1)
		IF lnMenuCount=0
			RETURN .F.
		ENDIF
		IF lnMRow<=0 AND TYPE("thisform")=="O" AND ;
				LOWER(thisform.BaseClass)=="toolbar"
			lnMRow=IIF(thisform.DockPosition=3,SROWS(),0)
		ENDIF
		lcMenu=IIF(EMPTY(tcParentMenu),SYS(2015),ALLTRIM(tcParentMenu))
		this.cMenu=lcMenu
		lnArrayColumns=ALEN(this.aMenu,2)
		llMultiArray=(lnArrayColumns>0)
		DEACTIVATE POPUP (lcMenu)
		CLEAR TYPEAHEAD
		IF EMPTY(tcParentMenu)
			DEFINE POPUP (lcMenu) ;
					FROM lnMRow,lnMCol ;
					MARGIN ;
					SHORTCUT
			ON SELECTION POPUP (lcMenu) DEACTIVATE MENU (lcMenu)
		ENDIF
		lnSkipCount=0
		FOR lnCount = 1 TO lnMenuCount
			lcMenuItem=IIF(llMultiArray,this.aMenu[lnCount,1],this.aMenu[lnCount])
			IF TYPE("lcMenuItem")#"C" OR EMPTY(lcMenuItem) OR ;
					((lnCount=1 OR lnCount=lnMenuCount) AND ALLTRIM(lcMenuItem)=="\-")
				lnSkipCount=lnSkipCount+1
				LOOP
			ENDIF
			lnBar=lnCount-lnSkipCount
			llSetMark=.F.
			IF LEFT(lcMenuItem,1)=="^"
				lcMenuItem=SUBSTR(lcMenuItem,2)
				llSetMark=.T.
			ENDIF
			IF lnArrayColumns>=3 AND NOT EMPTY(this.aMenu[lnCount,3])
				lcClauses=ALLTRIM(this.aMenu[lnCount,3])
			ELSE
				lcClauses=""
			ENDIF
			IF EMPTY(lcClauses)
				DEFINE BAR lnBar OF (lcMenu) PROMPT (lcMenuItem)
			ELSE
				DEFINE BAR lnBar OF (lcMenu) PROMPT (lcMenuItem) &lcClauses
			ENDIF
			IF llSetMark
				SET MARK OF BAR (lnBar) OF (lcMenu) TO .T.
			ENDIF
			IF NOT llMultiArray
				LOOP
			ENDIF
			luMenuSelection=this.aMenu[lnCount,2]
			IF TYPE("luMenuSelection")=="O" AND NOT ISNULL(luMenuSelection)
				lcMenu2=SYS(2015)
				DEFINE POPUP (lcMenu2) ;
						MARGIN ;
						SHORTCUT
				ON SELECTION POPUP (lcMenu2) DEACTIVATE MENU (lcMenu2)
				ON BAR lnBar OF (lcMenu) ACTIVATE POPUP (lcMenu2)
				IF EMPTY(luMenuSelection.cOnSelection)
					luMenuSelection.cOnSelection=this.cOnSelection
				ENDIF
				luMenuSelection.ActivateMenu(lcMenu2)
				LOOP
			ENDIF
			IF EMPTY(luMenuSelection)
				luMenuSelection=ALLTRIM(this.cOnSelection)
			ENDIF
			IF NOT EMPTY(luMenuSelection)
				ON SELECTION BAR lnBar OF (lcMenu) &luMenuSelection
			ENDIF
		ENDFOR
		IF lnSkipCount>=lnMenuCount OR NOT EMPTY(tcParentMenu)
			RETURN
		ENDIF
		ACTIVATE POPUP (lcMenu) BAR (this.nDefaultBar)
		IF NOT EMPTY(this.cMenu)
			DEACTIVATE POPUP (this.cMenu)
		ENDIF
		this.cMenu=""
		DOEVENTS
		
	ENDPROC

	PROCEDURE addmenubar
		LPARAMETERS tcPrompt,tcOnSelection,tcClauses,tnElementNumber,tlMark,tlDisabled,tlBold
		LOCAL lcPrompt,lcClauses,lnElementNumber,lnMenuCount,lnArrayColumns,lnIndex,oShortCutMenu
		
		IF EMPTY(tcPrompt)
			RETURN .F.
		ENDIF
		IF TYPE("tcPrompt")=="O" AND NOT ISNULL(tcPrompt)
			oShortCutMenu=tcPrompt
			tcPrompt=.NULL.
			FOR lnIndex = 1 TO ALEN(oShortCutMenu.aMenu,1)
				this.AddMenuBar(oShortCutMenu.aMenu[lnIndex,1],oShortCutMenu.aMenu[lnIndex,2], ;
						oShortCutMenu.aMenu[lnIndex,3])
			ENDFOR
			RETURN
		ENDIF
		lcPrompt=tcPrompt
		lcClauses=IIF(EMPTY(tcClauses),"",tcClauses)
		IF tlMark
			lcPrompt="^"+lcPrompt
		ENDIF
		IF tlDisabled
			lcClauses=lcClauses+[ SKIP FOR .T.]
		ENDIF
		IF tlBold
			lcClauses=lcClauses+[ STYLE "B"]
		ENDIF
		lnMenuCount=ALEN(this.aMenu,1)
		lnArrayColumns=ALEN(this.aMenu,2)
		IF lnMenuCount<=1 AND EMPTY(this.aMenu[1])
			lnMenuCount=1
			lnArrayColumns=3
		ELSE
			lnMenuCount=lnMenuCount+1
		ENDIF
		lnIndex=lnMenuCount
		DIMENSION this.aMenu[lnIndex,lnArrayColumns]
		IF TYPE("tnElementNumber")=="N"
			lnElementNumber=MAX(INT(tnElementNumber),1)
			IF lnElementNumber<lnMenuCount
				IF AINS(this.aMenu,lnElementNumber)#1
					RETURN .F.
				ENDIF
				lnIndex=lnElementNumber
			ENDIF
		ENDIF
		IF lnArrayColumns<=1
			this.aMenu[lnIndex]=lcPrompt
			RETURN
		ENDIF
		this.aMenu[lnIndex,1]=lcPrompt
		this.aMenu[lnIndex,2]=tcOnSelection
		IF lnArrayColumns>=3
			this.aMenu[lnIndex,3]=lcClauses
		ENDIF
		
	ENDPROC

	PROCEDURE addmenuseparator
		LPARAMETERS tnElementNumber
		
		this.AddMenuBar("\-",,,tnElementNumber)
		
	ENDPROC

	PROCEDURE clearmenu
		DIMENSION this.aMenu[1]
		this.aMenu=""
		this.cOnSelection=""
		
	ENDPROC

	PROCEDURE deactivatemenu
		IF EMPTY(this.cMenu)
			RETURN
		ENDIF
		DEACTIVATE POPUP (this.cMenu)
		this.cMenu=""
		DOEVENTS
		
	ENDPROC

	PROCEDURE Init
		this.ClearMenu
		
	ENDPROC

	PROCEDURE newmenu
		LOCAL toObject
		LOCAL oNewObject,lcClass,lcClassLibrary,lcBaseClass,lcAlias,llAddLibrary
		
		IF TYPE("toObject")#"O" OR ISNULL(toObject)
			toObject=this
		ENDIF
		lcClass=LOWER(toObject.Class)
		lcClassLibrary=LOWER(toObject.ClassLibrary)
		lcBaseClass=LOWER(toObject.BaseClass)
		IF EMPTY(lcClassLibrary)
			oNewObject=CREATEOBJECT(lcBaseClass)
			RETURN oNewObject
		ENDIF
		lcAlias=LOWER(SYS(2015))
		llAddLibrary=(ATC(lcClassLibrary,SET("CLASSLIB"))=0)
		IF llAddLibrary
			SET CLASSLIB TO (lcClassLibrary) ALIAS (lcAlias) ADDITIVE
		ENDIF
		oNewObject=CREATEOBJECT(lcClass)
		IF llAddLibrary
			RELEASE CLASSLIB ALIAS (lcAlias)
		ENDIF
		RETURN oNewObject
		
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		RELEASE this
		
	ENDPROC

	PROCEDURE setmenu
		LPARAMETERS toObject
		LOCAL lcClass,lnCount,lnCount2,llDisabled,lnMethodCodeNo,lnMethodCodeCount
		
		toObject.nDefaultBar=1
		oTHIS.nEditClass=0
		toObject.ClearMenu
		IF oTHIS.nSuperClassCount=0
			WAIT CLEAR
			WAIT WINDOW M_SPRCLSCODE_NOTFOUND_LOC NOWAIT
			RETURN .F.
		ENDIF
		IF oTHIS.nSuperClassCount=1
			oTHIS.nEditClass=1
			RETURN
		ENDIF
		lnMethodCodeNo=0
		lnMethodCodeCount=0
		FOR lnCount = oTHIS.nSuperClassCount TO 1 STEP -1
			IF EMPTY(oTHIS.aSuperClass[lnCount,3])
				LOOP
			ENDIF
			lnMethodCodeCount=lnMethodCodeCount+1
			IF lnMethodCodeNo=0
				lnMethodCodeNo=lnCount
			ENDIF
		ENDFOR
		IF lnMethodCodeCount=0
			WAIT CLEAR
			WAIT WINDOW M_SPRCLSCODE_NOTFOUND_LOC NOWAIT
			RETURN .F.
		ENDIF
		IF lnMethodCodeCount=1
			oTHIS.nEditClass=lnMethodCodeNo
			RETURN
		ENDIF
		lnCount2=0
		FOR lnCount = oTHIS.nSuperClassCount TO 1 STEP -1
			lcClass=LOWER(oTHIS.aSuperClass[lnCount,1])
			llDisabled=(EMPTY(oTHIS.aSuperClass[lnCount,3]) OR ;
					(NOT oTHIS.lIncludeObject AND lcClass==LOWER(oTHIS.oObject.Name)))
			toObject.AddMenuBar(SPACE(4*lnCount2)+lcClass, ;
					"oTHIS.nEditClass="+ALLTRIM(STR(lnCount)),,,,llDisabled)
			lnCount2=lnCount2+1
			IF NOT llDisabled
				toObject.nDefaultBar=lnCount2
			ENDIF
		ENDFOR
		IF oTHIS.lIncludeObject
			llDisabled=EMPTY(GETPEM(oTHIS.oObject,oTHIS.cMethod))
			toObject.AddMenuBar(SPACE(4*lnCount2)+oTHIS.oObject.Name, ;
					"oTHIS.nEditClass=-1",,,,llDisabled)
			lnCount2=lnCount2+1
			IF NOT llDisabled
				toObject.nDefaultBar=lnCount2
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE showmenu
		RETURN this.ActivateMenu()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS objectlinebutton AS superclassbutton OF "supercls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	Caption = "?"
	lrefreshobjectwaitwindow = .F.
	Name = "objectlinebutton"
	ToolTipText = "Object Line Syntax Builder (IntelliSense)"
	
	PROCEDURE Click
		LOCAL lcFileName
		
		lcFileName=LOWER(FULLPATH("OLSBldr.scx",this.ClassLibrary))
		IF SuperclassButton::Click()
			IF WEXIST(this.cWinOnTop)
				ACTIVATE WINDOW (this.cWinOnTop)
			ENDIF
			DO FORM (lcFileName) WITH (this.oObject),(this.cWinOnTop)
		ELSE
			DO FORM (lcFileName)
		ENDIF
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL lcFileName
		
		lcFileName=LOWER(FULLPATH("OLSBldr.scx",this.ClassLibrary))
		DO FORM (lcFileName)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclassbutton AS commandbutton 		&& Standard abstract  command button.
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	*<DefinedPropArrayMethod>
		*m: editmethod
		*m: editsuperclassmethod
		*m: findobject		&& Finds an object by name within the container object being edited in design mode.
		*m: getwinontop
		*m: help
		*m: keyboardstuff
		*m: keyboardstuffparams
		*m: refreshobject
		*m: refreshparams
		*m: refreshsuperclassname		&& Refreshes the cSuperclassMethod property.
		*m: release		&& Releases object from memory.
		*p: builder
		*p: builderx
		*p: cclass		&& Name of related parent classes of class (or name of class of object) being edited.
		*p: cclasslibrary
		*p: cmethod		&& Name of method being edited.
		*p: cmethodcode
		*p: cmethods
		*p: cparams
		*p: csuperclassmethod		&& Name of super class and method in one string separated by scope resolution operator (::).
		*p: csuperclasstext
		*p: cversion
		*p: cwinontop		&& Current window on top based on WONTOP().
		*p: lincludeobject
		*p: linsertdodefault
		*p: lrefreshobjectwaitwindow
		*p: nbutton
		*p: neditclass
		*p: nendpos
		*p: nrecno
		*p: nshift
		*p: nstartpos
		*p: nsuperclasscount
		*p: oobject		&& Object reference of object being edited.
		*a: asuperclass[1,3]
	*</DefinedPropArrayMethod>

	builder = 
	builderx = 
	Caption = ""
	cclass = 		&& Name of related parent classes of class (or name of class of object) being edited.
	cclasslibrary = 
	cmethod = 		&& Name of method being edited.
	cmethodcode = 
	cmethods = 
	cparams = 
	csuperclassmethod = 		&& Name of super class and method in one string separated by scope resolution operator (::).
	csuperclasstext = Superclass
	cversion = 
	cwinontop = 		&& Current window on top based on WONTOP().
	FontBold = .T.
	FontName = "Wingdings"
	FontSize = 12
	Height = 22
	lrefreshobjectwaitwindow = .T.
	Name = "superclassbutton"
	nbutton = 0
	neditclass = 0
	nendpos = 0
	nrecno = 0
	nshift = 0
	nstartpos = 0
	nsuperclasscount = 0
	oobject = .NULL.		&& Object reference of object being edited.
	Width = 24
	
	PROCEDURE Click
		IF NOT this.RefreshObject() OR NOT this.RefreshSuperclassName() OR ;
				NOT this.RefreshParams()
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE editmethod
		LPARAMETERS tcClass
		LOCAL lnRange1,lnRange2,lcTempFile,lcCursor,lcObjCode,lcClass,lcClassLibrary
		LOCAL lcOldMethods,lcOldMethodCode,lcNewMethodCode,lcLastSetClassLib,llVisible
		LOCAL lnStartPos,lnEndPos,lnLastSelect,lnLastSetMemoWidth,lnRecNo,lcAlias
		
		#DEFINE CR			CHR(13)
		#DEFINE LF			CHR(10)
		#DEFINE CR_LF		CR+LF
		
		llVisible=thisform.Visible
		IF EMPTY(this.cClass) OR EMPTY(this.cClassLibrary) OR ;
				EMPTY(this.nRecNo) OR EMPTY(this.cMethodCode)
			RETURN .F.
		ENDIF
		IF EMPTY(tcClass)
			IF NOT this.lIncludeObject AND LOWER(this.oObject.Class)==LOWER(this.oObject.Name)
				lcClass=LOWER(this.oObject.ParentClass)
			ELSE
				lcClass=LOWER(this.oObject.Class)
			ENDIF
		ELSE
			lcClass=LOWER(ALLTRIM(tcClass))
		ENDIF
		lcClassLibrary=this.cClassLibrary
		lnRecNo=this.nRecNo
		lcOldMethods=this.cMethods
		lcOldMethodCode=this.cMethodCode
		lnStartPos=this.nStartPos
		lnEndPos=this.nEndPos
		lnLastSelect=SELECT()
		lcAlias="vcxdata"
		IF USED(lcAlias)
			USE IN (lcAlias)
		ENDIF
		SELECT 0
		USE (lcClassLibrary) AGAIN ALIAS (lcAlias) SHARED 
		IF NOT USED()
			SELECT (lnLastSelect)
			EXIT
		ENDIF
		lcCursor=this.cSuperclassText+"_"+lcClass
		IF USED(lcCursor)
			USE IN (lcCursor)
		ENDIF
		SELECT 0
		CREATE CURSOR (lcCursor) ((this.cMethod) M, Err M)
		INSERT INTO (lcCursor) ((this.cMethod)) ;
				VALUES (lcOldMethodCode)
		lnRange1=1
		lnRange2=1
		thisform.Hide
		thisform.Enabled=.F.
		DO WHILE .T.
			lnLastSetMemoWidth=SET("MEMOWIDTH")
			SET MEMOWIDTH TO 1024
			MODIFY MEMO (this.cMethod) RANGE lnRange1,lnRange2
			SET MEMOWIDTH TO (lnLastSetMemoWidth)
			lcNewMethodCode=EVALUATE(this.cMethod)
			IF lcNewMethodCode==lcOldMethodCode
				lnResult=7
			ELSE
				lnResult=MESSAGEBOX(M_SAVE_CHANGES_TO_LOC+" "+lcClass+ ;
						+"::"+this.cMethod+"?",35,thisform.Caption)
			ENDIF
			IF lnResult=2
				LOOP
			ENDIF
			IF lnResult=7
				IF USED(lcCursor)
					USE IN (lcCursor)
				ENDIF
				IF USED(lcAlias)
					USE IN (lcAlias)
				ENDIF
				SELECT (lnLastSelect)
				this.cSuperclassMethod=""
				thisform.Enabled=.T.
				thisform.Show
				RETURN .F.
			ENDIF
			DO WHILE LEFT(lcNewMethodCode,1)==LF OR LEFT(lcNewMethodCode,1)==CR
				lcNewMethodCode=SUBSTR(lcNewMethodCode,2)
			ENDDO
			DO WHILE RIGHT(lcNewMethodCode,1)==LF OR RIGHT(lcNewMethodCode,1)==CR
				lcNewMethodCode=LEFT(lcNewMethodCode,LEN(lcNewMethodCode)-1)
			ENDDO
			lcNewMethods=STRTRAN(LEFT(lcOldMethods,lnStartPos-1)+lcNewMethodCode+ ;
					CR_LF+SUBSTR(lcOldMethods,lnEndPos),LF+LF,CR_LF)
			lcTempFile=LOWER(FULLPATH(LOWER(SYS(2015)),lcClassLibrary))
			SELECT (lcAlias)
			COPY TO (lcTempFile+".vcx") FOR RECNO()=1 OR RECNO()=lnRecNo
			SELECT 0
			USE (lcTempFile+".vcx")
			SET FILTER TO NOT DELETED() AND NOT EMPTY(TimeStamp) AND NOT Platform=="COMMENT "
			LOCATE
			REPLACE Methods WITH lcNewMethods
			USE
			COMPILE FORM (lcTempFile+".vcx")
			USE (lcTempFile+".vcx")
			SET FILTER TO NOT DELETED() AND NOT EMPTY(TimeStamp) AND NOT Platform=="COMMENT "
			LOCATE
			lcObjCode=ObjCode
			USE
			ERASE (lcTempFile+".vcx")
			ERASE (lcTempFile+".vct")
			IF NOT FILE(lcTempFile+".err")
				ERASE (lcTempFile+".err")
				EXIT
			ENDIF
			SELECT (lcCursor)
			APPEND MEMO Err FROM (lcTempFile+".err") OVERWRITE
			REPLACE (this.cMethod) WITH lcNewMethodCode
			ERASE (lcTempFile+".err")
			WAIT CLEAR
			WAIT WINDOW LEFT(Err,254) NOWAIT
		ENDDO
		SELECT (lcAlias)
		GOTO lnRecNo
		REPLACE Methods WITH lcNewMethods, ObjCode WITH lcObjCode
		IF USED(lcCursor)
			USE IN (lcCursor)
		ENDIF
		IF USED(lcAlias)
			USE IN (lcAlias)
		ENDIF
		SELECT (lnLastSelect)
		this.cSuperclassMethod=""
		thisform.AddClass(lcClass)
		thisform.AddClass(this.oObject.ParentClass)
		thisform.AddClass(this.oObject.Class)
		IF llVisible
			thisform.Enabled=.T.
			thisform.Show
		ENDIF
		
	ENDPROC

	PROCEDURE editsuperclassmethod
		LPARAMETERS tlParentClassOnly
		LOCAL lcClass,lcClass2,lcClassLibrary,lcClassLibrary2
		LOCAL lcProcedure,llMatch,lcOldMethods,lcOldMethodCode
		LOCAL lcCursor,lnAtPos,lnRecNo,lcAlias,lnLastSelect
		
		#DEFINE CR			CHR(13)
		#DEFINE LF			CHR(10)
		#DEFINE CR_LF		CR+LF
		
		this.nSuperClassCount=0
		DIMENSION this.aSuperClass[1,7]
		this.aSuperClass=""
		IF EMPTY(this.cClass) OR TYPE("this.oObject.BaseClass")#"C" OR ;
				LOWER(this.cClass)==LOWER(this.oObject.BaseClass)
			RETURN .F.
		ENDIF
		lnLastSelect=SELECT()
		IF NOT this.lIncludeObject AND LOWER(this.oObject.Class)==LOWER(this.oObject.Name)
			lcClass=LOWER(this.oObject.ParentClass)
		ELSE
			lcClass=LOWER(this.oObject.Class)
		ENDIF
		lcClassLibrary=LOWER(this.oObject.ClassLibrary)
		lcAlias="vcxdata"
		lnAtPos=0
		llMatch=.F.
		DO WHILE .T.
			IF EMPTY(lcClassLibrary)
				RETURN .F.
			ENDIF
			IF NOT FILE(lcClassLibrary)
				lcClassLibrary=LOWER(GETFILE("vcx",M_WHERE_IS_LOC+" "+lcClassLibrary+"?"))
				IF EMPTY(lcClassLibrary)
					RETURN .F.
				ENDIF
			ENDIF
			lcOldMethods=""
			IF USED(lcAlias)
				USE IN (lcAlias)
			ENDIF
			SELECT 0
			USE (lcClassLibrary) AGAIN ALIAS (lcAlias) SHARED 
			IF NOT USED()
				EXIT
			ENDIF
			SET FILTER TO NOT DELETED() AND NOT EMPTY(TimeStamp) AND NOT Platform=="COMMENT "
			lcOldMethods=""
			LOCATE FOR LOWER(ALLTRIM(ObjName))==lcClass AND EMPTY(Parent)
			IF EOF()
				EXIT
			ENDIF
			lcClass2=LOWER(ALLTRIM(Class))
			lcClassLibrary2=LOWER(FULLPATH(ALLTRIM(ClassLoc),lcClassLibrary))
			lcOldMethods=Methods
			lcProcedure="PROCEDURE "+this.cMethod+CR
			lnAtPos=ATC(lcProcedure,lcOldMethods)
			this.nSuperClassCount=this.nSuperClassCount+1
			DIMENSION this.aSuperClass[this.nSuperClassCount,7]
			this.aSuperClass[this.nSuperClassCount,1]=lcClass
			this.aSuperClass[this.nSuperClassCount,2]=lcClassLibrary
			this.aSuperClass[this.nSuperClassCount,3]=""
			this.aSuperClass[this.nSuperClassCount,4]=""
			this.aSuperClass[this.nSuperClassCount,5]=0
			this.aSuperClass[this.nSuperClassCount,6]=0
			this.aSuperClass[this.nSuperClassCount,7]=0
			IF lnAtPos>0
				lnRecNo=RECNO()
				lnStartPos=lnAtPos+LEN(lcProcedure)
				lcOldMethodCode=SUBSTR(SUBSTR(lcOldMethods,LEN(lcProcedure)+1),lnAtPos)
				DO WHILE LEFT(lcOldMethodCode,1)==LF OR LEFT(lcOldMethodCode,1)==CR
					lcOldMethodCode=SUBSTR(lcOldMethodCode,2)
				ENDDO
				lnAtPos=ATC("ENDPROC"+CR,lcOldMethodCode)
				IF lnAtPos>0
					lnEndPos=lnStartPos+lnAtPos-1
					lcOldMethodCode=LEFT(lcOldMethodCode,lnAtPos-1)
				ELSE
					lnEndPos=LEN(lcOldMethods)
				ENDIF
				DO WHILE RIGHT(lcOldMethodCode,1)==LF OR RIGHT(lcOldMethodCode,1)==CR
					lcOldMethodCode=LEFT(lcOldMethodCode,LEN(lcOldMethodCode)-1)
				ENDDO
				lcOldMethodCode=lcOldMethodCode+CR_LF
				this.aSuperClass[this.nSuperClassCount,3]=lcOldMethodCode
				this.aSuperClass[this.nSuperClassCount,4]=lcOldMethods
				this.aSuperClass[this.nSuperClassCount,5]=lnStartPos
				this.aSuperClass[this.nSuperClassCount,6]=lnEndPos
				this.aSuperClass[this.nSuperClassCount,7]=lnRecNo
				IF NOT llMatch
					llMatch=.T.
					this.nEditClass=this.nSuperClassCount
					this.cClass=lcClass
					this.cClassLibrary=lcClassLibrary
					this.cMethods=lcOldMethods
					this.cMethodCode=lcOldMethodCode
					this.nStartPos=lnStartPos
					this.nEndPos=lnEndPos
					IF tlParentClassOnly
						EXIT
					ENDIF
				ENDIF
			ENDIF
			IF EMPTY(Class) OR EMPTY(ClassLoc)
				EXIT
			ENDIF
			IF USED(lcAlias)
				USE IN (lcAlias)
			ENDIF
			lcClass=lcClass2
			lcClassLibrary=lcClassLibrary2
		ENDDO
		IF USED(lcAlias)
			USE IN (lcAlias)
		ENDIF
		SELECT (lnLastSelect)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		RETURN thisform.Error(nError,cMethod,nLine)
		
	ENDPROC

	PROCEDURE findobject		&& Finds an object by name within the container object being edited in design mode.
		LPARAMETERS tcObjName,toObject
		LOCAL lcObjName,oObject,lnCount
		LOCAL laChild[1]
		
		IF EMPTY(tcObjName) OR TYPE("toObject")#"O" OR ;
				AMEMBERS(laChild,toObject,2)=0
			RETURN .NULL.
		ENDIF
		lcObjName=LOWER(ALLTRIM(tcObjName))
		oObject=.NULL.
		FOR lnCount = 1 TO ALEN(laChild)
			IF LOWER(laChild[lnCount])==lcObjName
				oObject=toObject.&lcObjName
			ELSE
				oObject=this.FindObject(lcObjName,toObject.&laChild[lnCount])
			ENDIF
			IF NOT ISNULL(oObject)
				EXIT
			ENDIF
		ENDFOR
		RETURN oObject
		
	ENDPROC

	PROCEDURE getwinontop
		LOCAL lcWinOnTop,lcWChild,lnCount
		
		lcWinOnTop=""
		WCHILD(0)
		FOR lnCount = 0 TO WCHILD()
			lcWChild=WCHILD(lnCount)
			IF EMPTY(lcWChild)
				EXIT
			ENDIF
			IF "."$lcWChild OR LOWER(lcWChild)=="command"
				lcWinOnTop=lcWChild
			ENDIF
		ENDFOR
		IF LOWER(lcWinOnTop)=="command"
			RETURN lcWinOnTop
		ENDIF
		IF EMPTY(lcWinOnTop) AND "."$WONTOP()
			lcWinOnTop=WONTOP()
		ENDIF
		RETURN lcWinOnTop
		
	ENDPROC

	PROCEDURE help
		LOCAL lcFileName
		
		lcFileName=LOWER(FULLPATH("supercls.txt",this.ClassLibrary))
		IF NOT FILE(lcFileName)
			WAIT CLEAR
			WAIT WINDOW "Help not found" NOWAIT
			RETURN .F.
		ENDIF
		MODIFY FILE (lcFileName) NOEDIT NOWAIT
		
	ENDPROC

	PROCEDURE keyboardstuff
		IF WEXIST(this.cWinOnTop)
			ACTIVATE WINDOW (this.cWinOnTop)
		ENDIF
		IF SET("TYPEAHEAD")<64
			SET TYPEAHEAD TO 64
		ENDIF
		IF NOT EMPTY(this.cParams) AND this.nShift=1
			KEYBOARD [LPARAMETERS ] PLAIN
			this.KeyboardStuffParams
			KEYBOARD [{ENTER}{ENTER}] PLAIN
		ENDIF
		KEYBOARD [IF NOT ]+IIF(this.lInsertDoDefault,[DODEFAULT],this.cSuperclassMethod)+[(] PLAIN
		this.KeyboardStuffParams
		KEYBOARD [){ENTER}{TAB}RETURN .F.{ENTER}{BACKSPACE}ENDIF{ENTER}] PLAIN
		
	ENDPROC

	PROCEDURE keyboardstuffparams
		LOCAL lnCount
		
		IF EMPTY(this.cParams)
			RETURN .F.
		ENDIF
		IF SET("TYPEAHEAD")<64
			SET TYPEAHEAD TO 64
		ENDIF
		FOR lnCount = 0 TO INT(LEN(this.cParams)/64)
			KEYBOARD SUBSTR(this.cParams,64*lnCount+1,64) PLAIN
		ENDFOR
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		this.nButton=nButton
		this.nShift=nShift
		
	ENDPROC

	PROCEDURE refreshobject
		LOCAL lnWChilds,oObject,lcObjName,lnMousePointer,lnCount,lnAtPos
		LOCAL laSelObj[1]
		
		this.oObject=.NULL.
		this.cMethodCode=""
		this.cParams=""
		this.cWinOnTop=this.GetWinOnTop()
		IF LOWER(RIGHT(this.cWinOnTop,12))==" [read only]"
			this.cWinOnTop=ALLTRIM(LEFT(this.cWinOnTop,LEN(this.cWinOnTop)-12))
		ENDIF
		IF EMPTY(this.cWinOnTop) OR " "$this.cWinOnTop OR ;
				OCCURS(".",this.cWinOnTop)=0
			IF this.lRefreshObjectWaitWindow
				WAIT CLEAR
				WAIT WINDOW M_CODE_WIN_NOT_ACTIVE_LOC NOWAIT
			ENDIF
			RETURN .F.
		ENDIF
		lnAtPos=AT(".",this.cWinOnTop)
		lcObjName=LOWER(LEFT(this.cWinOnTop,lnAtPos-1))
		this.cMethod=LOWER(SUBSTR(this.cWinOnTop,lnAtPos+1))
		IF ASELOBJ(laSelObj,1)=0
			IF this.lRefreshObjectWaitWindow
				WAIT CLEAR
				WAIT WINDOW M_CODE_WIN_NOT_ACTIVE_LOC NOWAIT
			ENDIF
			RETURN .F.
		ENDIF
		oObject=laSelObj[1]
		IF LOWER(oObject.Name)==lcObjName
			this.oObject=oObject
		ELSE
			RELEASE laSelObj
			DIMENSION laSelObj[1]
			DO CASE
				CASE LOWER(oObject.BaseClass)=="form" AND ;
						TYPE("oObject.parent")=="O" AND ;
						LOWER(oObject.parent.Name)==lcObjName
					this.oObject=oObject.parent
				CASE ASELOBJ(laSelObj)=1 AND LOWER(laSelObj[1].Name)==lcObjName
					this.oObject=laSelObj[1]
				OTHERWISE
					IF TYPE("oObject."+lcObjName)=="O"
						this.oObject=oObject.&lcObjName
					ELSE
						lnMousePointer=thisform.MousePointer
						thisform.MousePointer=11
						thisform.SetAll("MousePointer",11)
						this.oObject=this.FindObject(lcObjName,oObject)
						thisform.MousePointer=lnMousePointer
						thisform.SetAll("MousePointer",lnMousePointer)
					ENDIF
			ENDCASE
		ENDIF
		RELEASE laSelObj,oObject
		IF ISNULL(this.oObject)
			IF this.lRefreshObjectWaitWindow
				WAIT CLEAR
				WAIT WINDOW M_OBJECT_NOT_FOUND_LOC+CHR(13)+M_SELECT_OBJECT_EDIT_LOC NOWAIT
			ENDIF
			RETURN .F.
		ENDIF
		IF LOWER(this.oObject.Class)==LOWER(this.oObject.Name)
			this.cClass=LOWER(this.oObject.ParentClass)
		ELSE
			this.cClass=LOWER(this.oObject.Class)
		ENDIF
		
	ENDPROC

	PROCEDURE refreshparams
		LOCAL lcParams,lcMethodCode,lcCommand,lcMemLine,lnLastMLine,lnCount,lnAtPos
		
		IF ISNULL(this.oObject)
			this.cParams=""
			RETURN
		ENDIF
		this.EditSuperClassMethod
		lcMethodCode=this.oObject.ReadMethod(this.cMethod)
		IF EMPTY(lcMethodCode) OR TYPE("lcMethodCode")#"C"
			lcMethodCode=this.cMethodCode
			IF EMPTY(lcMethodCode) OR TYPE("lcMethodCode")#"C"
				this.cParams=""
				RETURN
			ENDIF
		ENDIF
		lcParams=""
		lnLastMLine=_mline
		_mline=0
		FOR lnCount = 1 TO MEMLINES(lcMethodCode)
			lcMemLine=ALLTRIM(STRTRAN(MLINE(lcMethodCode,1,_mline),CHR(9)," "))
			IF NOT EMPTY(lcParams)
				lcParams=lcParams+lcMemLine
			ELSE
				IF EMPTY(lcMemLine) OR INLIST(LEFT(lcMemLine,1),"*","&")
					LOOP
				ENDIF
				lcCommand=UPPER(LEFT(lcMemLine,4))
				IF lcCommand=="NOTE"
					LOOP
				ENDIF
				IF NOT INLIST(lcCommand,"LPAR","PARA")
					EXIT
				ENDIF
				lnAtPos=AT(" ",lcMemLine)
				IF lnAtPos=0
					EXIT
				ENDIF
				lcParams=lcParams+ALLTRIM(STRTRAN(SUBSTR(lcMemLine,lnAtPos+1)," ",""))
			ENDIF
			IF NOT RIGHT(lcParams,1)==";"
				EXIT
			ENDIF
			lcParams=ALLTRIM(LEFT(lcParams,LEN(lcParams)-1))
		ENDFOR
		_mline=lnLastMLine
		this.cParams=STRTRAN(lcParams,",",", ")
		
		
	ENDPROC

	PROCEDURE refreshsuperclassname		&& Refreshes the cSuperclassMethod property.
		this.cSuperclassMethod=this.cClass+"::"+this.cMethod
		
	ENDPROC

	PROCEDURE release		&& Releases object from memory.
		RELEASE this
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclasseditmethod AS superclassbutton OF "supercls.vcx" 		&& Button to edit superclass based on code snipppet window currently being edited.
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	*<DefinedPropArrayMethod>
		*m: editmethodcode		&& test
		*m: editmethodshortcutmenu
	*</DefinedPropArrayMethod>

	Caption = "!"
	Name = "superclasseditmethod"
	
	PROCEDURE Click
		IF NOT SuperclassButton::Click()
			RETURN .F.
		ENDIF
		this.EditSuperClassMethod
		this.EditMethodCode
		
	ENDPROC

	PROCEDURE editmethodcode		&& test
		this.EditMethodShortcutMenu
		IF this.nEditClass<=0
			RETURN
		ENDIF
		this.cClass=this.aSuperClass[this.nEditClass,1]
		this.cClassLibrary=this.aSuperClass[this.nEditClass,2]
		this.cMethodCode=this.aSuperClass[this.nEditClass,3]
		this.cMethods=this.aSuperClass[this.nEditClass,4]
		this.nStartPos=this.aSuperClass[this.nEditClass,5]
		this.nEndPos=this.aSuperClass[this.nEditClass,6]
		this.nRecNo=this.aSuperClass[this.nEditClass,7]
		this.EditMethod(this.cClass)
		
	ENDPROC

	PROCEDURE editmethodshortcutmenu
		PRIVATE oTHIS
		
		oTHIS=this
		thisform.oEditMethodShortcutMenu.SetMenu(thisform.oEditMethodShortcutMenu)
		RETURN thisform.oEditMethodShortcutMenu.ActivateMenu()
		
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		this.ToolTipText=M_EDIT_LOC+" "+this.cSuperclassText+" "+M_METHOD_LOC
		
	ENDPROC

	PROCEDURE RightClick
		IF NOT SuperclassButton::Click()
			RETURN .F.
		ENDIF
		this.EditSuperClassMethod(.T.)
		this.EditMethodCode
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclasshelp AS superclassbutton OF "supercls.vcx" 		&& Button for Superclass Utilities help.
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	Caption = "?"
	FontName = "Arial"
	Name = "superclasshelp"
	ToolTipText = "Help"
	
	PROCEDURE Click
		this.Help
		
	ENDPROC

	PROCEDURE RightClick
		IF TYPE("thisform.cVersion")=="C" AND NOT EMPTY(thisform.cVersion)
			WAIT CLEAR
			WAIT WINDOW thisform.cVersion NOWAIT
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclassinsertmethodcall AS superclassbutton OF "supercls.vcx" 		&& Button to insert superclass method call at current cursor position in code snipppet window currently being edited.
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	Caption = "Ç"
	Name = "superclassinsertmethodcall"
	
	PROCEDURE Click
		IF NOT SuperclassButton::Click()
			RETURN .F.
		ENDIF
		this.lInsertDoDefault=.T.
		this.KeyboardStuff
		
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		this.ToolTipText="Insert "+this.cSuperclassText+" Method Call"
		
	ENDPROC

	PROCEDURE RightClick
		IF NOT SuperclassButton::Click()
			RETURN .F.
		ENDIF
		this.lInsertDoDefault=.F.
		this.KeyboardStuff
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclasstimer AS timer 		&& Timer used to automatically hide/show related toolbar and also used to auto CLEAR CLASS the clear class array list.
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	*<DefinedPropArrayMethod>
		*m: addclass		&& Adds class to array list to automatically execute CLEAR CLASS after all Form/Class Designer instances are closed.
		*m: release		&& Releases object from memory.
		*p: builder
		*p: builderx
		*p: cversion
		*p: nclasscount		&& Number of array elements in aClassList[].
		*p: oparent		&& Object reference of related Superclass Utilities parent container.
		*a: aclasslist[1,0]		&& Array list of classes to be automatically cleared via CLEAR CLASS.
	*</DefinedPropArrayMethod>

	builder = 
	builderx = 
	cversion = 
	Height = 24
	Interval = 500
	Name = "superclasstimer"
	nclasscount = 0		&& Number of array elements in aClassList[].
	oparent = .NULL.		&& Object reference of related Superclass Utilities parent container.
	Width = 23
	
	PROCEDURE addclass		&& Adds class to array list to automatically execute CLEAR CLASS after all Form/Class Designer instances are closed.
		LPARAMETERS tcClass
		LOCAL lcClass
		
		IF EMPTY(tcClass) OR TYPE("tcClass")#"C"
			RETURN .F.
		ENDIF
		lcClass=LOWER(ALLTRIM(tcClass))
		FOR lnCount = 1 TO this.nClassCount
			IF this.aClassList[lnCount]==lcClass
				RETURN
			ENDIF
		ENDFOR
		FOR lnCount = 1 TO this.nClassCount
			IF EMPTY(this.aClassList[lnCount])
				this.aClassList[lnCount]=lcClass
				RETURN
			ENDIF
		ENDFOR
		this.nClassCount=this.nClassCount+1
		DIMENSION this.aClassList[this.nClassCount]
		this.aClassList[this.nClassCount]=lcClass
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		RETURN thisform.Error(nError,cMethod,nLine)
		
	ENDPROC

	PROCEDURE release		&& Releases object from memory.
		RELEASE this
		
	ENDPROC

	PROCEDURE Timer
		LOCAL lcClass,lnCount,lnSelObj,llVisible,lcWinOnTop
		LOCAL laSelObj[1],laInstance[1],lnAtPos
		
		IF WVISIBLE("TRACE")
			this.Enabled=.F.
			this.oParent.Show
			RETURN
		ENDIF
		IF WONTOP()=="EXPRESSION BUILDER" OR WONTOP()=="TRACE" OR WONTOP()=="DEBUG" 
			RETURN
		ENDIF
		lcWinOnTop=LOWER(WONTOP())
		IF TYPE("lcWinOnTop")#"C"
			lcWinOnTop=""
		ENDIF
		IF LOWER(RIGHT(lcWinOnTop,12))==" [read only]"
			lcWinOnTop=ALLTRIM(LEFT(lcWinOnTop,LEN(lcWinOnTop)-12))
		ENDIF
		lnAtPos=AT(".",lcWinOnTop)
		lnSelObj=ASELOBJ(laSelObj,1)
		IF NOT this.oParent.Enabled
			llVisible=.F.
		ELSE
			llVisible=(NOT (lnSelObj=0 OR lnAtPos=0 OR " "$lcWinOnTop OR ;
					LEFT(lcWinOnTop,13)=="classbrowser." OR ;
					INLIST(RIGHT(lcWinOnTop,3),"prg","txt","app","mpr","qpr","spr", ;
					"err","ini","bat","sys","bak")))
		ENDIF
		IF this.oParent.Visible#llVisible
			IF llVisible
				this.oParent.Show
			ELSE
				this.oParent.Hide
			ENDIF
		ENDIF
		IF lnSelObj=0
			FOR lnCount = 1 TO this.nClassCount
				lcClass=this.aClassList[lnCount]
				IF EMPTY(lcClass) OR AINSTANCE(laInstance,lcClass)>0
					LOOP
				ENDIF
				CLEAR CLASS (lcClass)
				this.aClassList[lnCount]=""
			ENDFOR
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS superclasstoolbar AS toolbar 		&& Standard abstract toolbar.
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "supercls.h"
	*<DefinedPropArrayMethod>
		*m: addclass		&& Adds class to array list to automatically execute CLEAR CLASS after all Form/Class Designer instances are closed.
		*m: inittimer		&& Initializes child timer object to be added to _screen as a global monitoring and auto-refresh timer.
		*m: releasetimer		&& Releases child timer object from _screen.
		*p: builder
		*p: builderx
		*p: cversion		&& Returns a character string containing the class version number.
		*p: lignoreerrors
		*p: ltimer
	*</DefinedPropArrayMethod>

	builder = 
	builderx = 
	Caption = "Superclass"
	cversion = 		&& Returns a character string containing the class version number.
	DataSession = 2
	Height = 22
	Left = 0
	ltimer = .T.
	Name = "superclasstoolbar"
	Top = 0
	Visible = .F.
	Width = 33
	
	PROCEDURE addclass		&& Adds class to array list to automatically execute CLEAR CLASS after all Form/Class Designer instances are closed.
		LPARAMETERS tcClass
		
		IF NOT this.lTimer
			RETURN .F.
		ENDIF
		this.InitTimer
		_screen.tmrSuperclass.AddClass(tcClass)
		
	ENDPROC

	PROCEDURE Destroy
		this.ReleaseTimer
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL lcOnError,lcErrorMsg,lcCodeLineMsg
		
		IF this.lIgnoreErrors
			RETURN .F.
		ENDIF
		lcOnError=UPPER(ALLTRIM(ON("ERROR")))
		IF NOT EMPTY(lcOnError)
			lcOnError=STRTRAN(STRTRAN(STRTRAN(lcOnError,"ERROR()","nError"), ;
					"PROGRAM()","cMethod"),"LINENO()","nLine")
			&lcOnError
			RETURN
		ENDIF
		lcErrorMsg=MESSAGE()+CHR(13)+CHR(13)+this.Name+CHR(13)+ ;
				"Error:           "+ALLTRIM(STR(nError))+CHR(13)+ ;
				"Method:       "+LOWER(ALLTRIM(cMethod))
		lcCodeLineMsg=MESSAGE(1)
		IF BETWEEN(nLine,1,100000) AND NOT lcCodeLineMsg="..."
			lcErrorMsg=lcErrorMsg+CHR(13)+"Line:            "+ALLTRIM(STR(nLine))
			IF NOT EMPTY(lcCodeLineMsg)
				lcErrorMsg=lcErrorMsg+CHR(13)+CHR(13)+lcCodeLineMsg
			ENDIF
		ENDIF
		WAIT CLEAR
		MESSAGEBOX(lcErrorMsg,16,_screen.Caption)
		
	ENDPROC

	PROCEDURE Init
		LOCAL laInstance[1]
		
		SET TALK OFF
		SET CONFIRM ON
		SET EXACT OFF
		SET EXCLUSIVE OFF
		SET MEMOWIDTH TO 1024
		SET MULTILOCKS ON
		SET PALETTE OFF
		SET POINT TO "."
		SET SAFETY OFF
		IF AINSTANCE(laInstance,this.Class)>=1
			RETURN .F.
		ENDIF
		this.Top=0
		this.Left=492
		this.InitTimer
		
	ENDPROC

	PROCEDURE inittimer		&& Initializes child timer object to be added to _screen as a global monitoring and auto-refresh timer.
		LOCAL lcLastSetClassLib
		LOCAL laInstance[1]
		
		IF NOT this.lTimer OR AINSTANCE(laInstance,this.Class)>=2
			RETURN .F.
		ENDIF
		IF TYPE("_screen.tmrSuperclass")#"O" OR ISNULL(_screen.tmrSuperclass)
			lcLastSetClassLib=SET("CLASSLIB")
			SET CLASSLIB TO (this.ClassLibrary) ADDITIVE
			_screen.AddObject("tmrSuperclass","SuperclassTimer")
			IF NOT SET("CLASSLIB")==lcLastSetClassLib
				SET CLASSLIB TO &lcLastSetClassLib
			ENDIF
			_screen.tmrSuperclass.oParent=this
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF NOT this.lTimer
			RETURN .F.
		ENDIF
		IF nButton=2 AND TYPE("_screen.tmrSuperclass")=="O"
			_screen.tmrSuperclass.Enabled=.T.
		ENDIF
		
	ENDPROC

	PROCEDURE Release
		RELEASE this
		
	ENDPROC

	PROCEDURE releasetimer		&& Releases child timer object from _screen.
		LOCAL laInstance[1]
		
		IF NOT this.lTimer OR AINSTANCE(laInstance,this.Class)>=1
			RETURN .F.
		ENDIF
		IF TYPE("_screen.tmrSuperclass")#"O" OR ;
				ISNULL(_screen.tmrSuperclass)
			RETURN
		ENDIF
		_screen.RemoveObject("tmrSuperclass")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS supercls AS superclasstoolbar OF "supercls.vcx" 		&& Superclass utilities toolbar.
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdEditMethod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdInsertMethodCall" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdObjectLineBuilder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="sepHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oEditMethodShortcutMenu" UniqueID="" Timestamp="" />

	#INCLUDE "supercls.h"
	cversion = Superclass Utility 06.02.0001
	Height = 31
	Left = 0
	Name = "supercls"
	Top = 0
	Width = 142

	ADD OBJECT 'cmdEditMethod' AS superclasseditmethod WITH ;
		Left = 5, ;
		Name = "cmdEditMethod", ;
		SpecialEffect = 2, ;
		TabIndex = 1, ;
		Top = 5, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="supercls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS superclasshelp WITH ;
		Left = 88, ;
		Name = "cmdHelp", ;
		SpecialEffect = 2, ;
		TabIndex = 4, ;
		Top = 5, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="supercls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdInsertMethodCall' AS superclassinsertmethodcall WITH ;
		Left = 30, ;
		Name = "cmdInsertMethodCall", ;
		SpecialEffect = 2, ;
		TabIndex = 2, ;
		Top = 5, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="supercls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdObjectLineBuilder' AS objectlinebutton WITH ;
		Left = 55, ;
		Name = "cmdObjectLineBuilder", ;
		SpecialEffect = 2, ;
		TabIndex = 3, ;
		Top = 5, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="supercls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'oEditMethodShortcutMenu' AS editmethodshortcutmenu WITH ;
		Left = 113, ;
		Name = "oEditMethodShortcutMenu", ;
		Top = 5
		*< END OBJECT: ClassLib="supercls.vcx" BaseClass="custom" />

	ADD OBJECT 'sepHelp' AS separator WITH ;
		Height = 0, ;
		Left = 88, ;
		Name = "sepHelp", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />

ENDDEFINE
